# compiler
Implementation of a compiler (lexer, parser, generator)

## Language syntax

Some examples of the new language can be found in `code.to_be_compiled`.

The following code

```
add_and_multiply x y =>
  (multiply 10 (add x y))
e
```

defines a new function that takes two parameters, `x` and `y`, and first adds their values and then multiplies the result by `10`. Finally, it returns the result.

The compiled Javascript is

```
function add_and_multiply(x, y) {
 return multiply(10, add(x, y));
}
```

## Target language

At the moment the target language is Javascript, but once the tree has been generated by the parser, a new code generator can be implemented for a different target. See `generator.py`.

## Inspect parsed tokens and tree

You can pass `--debug` to the compiler to inspect the parsed tokens and the parsing tree:

```
$ ./main.py --debug code.to_be_compiled
>>> parsed tokens:
['add_and_multiply', 'x', 'y', '=>', '(', 'multiply', '10', '(', 'add', 'x', 'y', ')', ')', 'e']

>>> parse tree:
RootNode(['DefNode(add_and_multiply, [\'x\', \'y\'], BodyNode([\'CallNode(multiply, [\\\'IntegerNode(10)\\\', "CallNode(add, [\\\'VarRefNode(x)\\\', \\\'VarRefNode(y)\\\'])"])\']))'])

>>> generated code:
function add_and_multiply(x, y) {
 return multiply(10, add(x, y));
}
```

